
#This script takes the OUtput from GUT and summarizes responses by Unit


# To Do -------------------------------------------------------------------
#eliminate species and model from directory structure and instead include as field in output table?  Maybe append to this table
#when run for different species or just run for all species and model types on the fly-- not make a user variable...?

# Dependencies ------------------------------------------------------------

require(ggplot2)
require(dplyr)
require(tidyr)

source(paste(GUPdir, "\\scripts\\plot.colors.R", sep=""))
source(paste(GUPdir, "\\scripts\\functions.R", sep=""))

###user variables defined in UpscaleWrapper.R###
PROJdir=PROJdir  #directory path to local project
GUPdir=GUPdir   #directory path to Github repo
selections=selections #directory path to input selections file generated by RSselection.R
gu.type=gu.type      #Options: UnitForm, GU #UnitShape not available at this time since I don't have maps of these in the database
RSlevels=RSlevels #optional vector argument to set RS factor order in graphs and displays, leave as  NA if alphabetical is desired
plottype=plottype   #Options: .tiff, .png, .pdf, "none"
myscales=myscales #Options: fixed or free x/y axis scales for tiled plot output
species=species   #Options: steelhead, chinook, ""
model=model    ##Options: nrei, fuzzy, ""
lifestage=lifestage  ##Options: spawner, juvenile

# set up data refs and output file structure----------------------------------------------------

print("set up data refs and output file structure...")

#make lifestage match model type    
if(model=="nrei"& lifestage!="juvenile"){lifestage="juvenile"
print("lifestage changed to juvenile for nrei results")}

#if(model=="fuzzy"){lifestage="spawner"
#print("lifestage set to spawner to match specified model")}

basesubdir=c("Outputs","response",  species, model, lifestage, "by.unit", gu.type)
create.subdirs(PROJdir, basesubdir)

#set OUTdir
OUTdir=paste(PROJdir, paste(basesubdir, collapse="\\"), sep="\\")

#delete any existing files in Output from previous runs
unlink(paste(OUTdir,"\\*", sep=""), recursive=T)

#Specify location of input metric tables
GUTdir=paste(GUPdir,"\\Database\\Metrics" , sep="")

#specify GUT output layer to draw data from based on gu.type
if(gu.type=="GU"){layer="Tier3_InChannel_GU"}
if(gu.type=="UnitForm" | gu.type=="UnitShape"){layer="Tier2_InChannel_Transition" }

#May need to change this in the future? depended on file naming conventions.  
#List GUToutput files corresponding to Layer
GUToutputlist=list.files(GUTdir)[grep(layer, list.files(GUTdir)) ]


# Reads in and restructures data----------------------------------------------------

print("reading in data and restructuring...")

#read in unit level  fish data
unitfishmetrics=read.csv(paste(GUTdir,GUToutputlist[grep(paste("Unit_Fish", sep=""), GUToutputlist)],sep="\\"), stringsAsFactors=F)

#makes layer with just site level resonse for model, species and lifestage specified. 
myvars=c(model, species, lifestage)
unitfish=unitfishmetrics%>%filter(model==myvars[1] & species==myvars[2] & lifestage==myvars[3])
if(length(unitfish[,1])==0){print("no results for specified species, model and lifestage, cannot run summaries")}


#Read in Unit Data and combines to add unit type as field
#I don't need this section now that the summary isn't by UnitID...

#unitmetrics=read.csv(paste(GUTdir,GUToutputlist[grep("unit", GUToutputlist)],sep="\\"),stringsAsFactors=F)

#read in unit type
#unittypes=read.csv(paste(GUTdir,GUToutputlist[grep("AllVisits", GUToutputlist)],sep="\\"),stringsAsFactors=F)%>%
#  rename(visit.id=VisitID)
#unittypes=unittypes[,c(which(names(unittypes)==gu.type), which(names(unittypes)=="visit.id", "Unit_ID"), which(names(unittypes)=="UnitID"))]
#unitfish=unittypes%>%full_join(unitfish, by=c("visit.id"))


#finds which column matches gu.type abd rename column to Unit
unitfish1=unitfish%>%rename(unit.type=gu.type)

#gathersdata and add ROI and variable fields so table is cleaner and easier to select from
unitfish.gather=gather(unitfish1, key="variable_old", value="value", area.delft:sd.suitable)
unitfish.gather$ROI=NA
unitfish.gather$variable=NA
unitfish.gather$ROI[grep("delft", unitfish.gather$variable_old)]="hydro"
unitfish.gather$ROI[grep("suitable", unitfish.gather$variable_old)]="suitable"
#unitfish.gather$ROI[grep("best", unitfish.gather$variable_old)]="best"
unitfish.gather$ROI[which(is.na(unitfish.gather$ROI))]="hydro"
unitfish.gather$variable[grep("pred.fish", unitfish.gather$variable_old)]="pred.fish"
unitfish.gather$variable[grep("area", unitfish.gather$variable_old)]="area"
unitfish.gather$variable[grep("med", unitfish.gather$variable_old)]="medModelVal"
unitfish.gather$variable[grep("mean", unitfish.gather$variable_old)]="meanModelVal"
unitfish.gather$variable[grep("sd", unitfish.gather$variable_old)]="sdModelVal"


#join selections to unitfish to add RS and condition variables to response.
response=selections%>%select(visit.id, RS, Condition, RScond)%>%full_join(unitfish.gather, by="visit.id")
#removes NA rows for RS from joined responses. Not sure why they were added?, something to do with the full join.
response.unitid=response%>%filter(!is.na(unit.type))%>%filter(!is.na(RS))%>%filter(!is.na(variable))


#do summary bf.density by u because handy in upscale to get standard deviation of density... but kind of a weird number conceptually 
#response.bf.density=response.unitid%>%filter(variable=="area" | variable=="pred.fish")%>%
#  group_by(visit.id, RS, Condition, unit.type, model, species, lifestage, variable_old, ROI, variable)%>%
#  summarize(value=sum(value, na.rm=T))


# Summarizes data for use in Upscale ----------------------------------------------------

print("Making and plotting stat summaries of responses...")
print("for RScond...")
byRScond=make.outputs.unit(indata=response.unitid, poolby="RScond", gu.type=gu.type, plottype=plottype, OUTdir=OUTdir, RSlevels=RSlevels)
print("for RS...")
byRS=make.outputs.unit(indata=response.unitid, poolby="RS", gu.type=gu.type, plottype=plottype, OUTdir=OUTdir, RSlevels=RSlevels)
print("for All...")
byall=make.outputs.unit(indata=response.unitid, poolby="", gu.type=gu.type, plottype=plottype, OUTdir=OUTdir, RSlevels=RSlevels)


# cleaning up ----------------------------------------------

print("erasing temporary variables")


keepvars=c("selections", "PROJdir","GUPdir", "plottype", "myscales" , "RSlevels", "gu.type", 
           "species", "model", "lifestage")

rm(list=ls()[-match(x = keepvars, table = ls())])

print("done")


#OLD STUFF




#visitlist=levels(as.factor(selections$visit))


#selects just response type and ROI identified
#for(i in 1:length(visitlist)){
#  area=filter(unitmetrics, visit==visitlist[i])%>%
#    select(Unit, totArea)
#  subresponse=filter(response, visit==visitlist[i])%>%
#    right_join(area, by="Unit")%>%
#    filter(!is.na(Unit))%>%
#    group_by(Unit)
#  
#  if(responsevar=="Density"& ROI=="bf"){
#    subresponse=summarize(subresponse, var=sum(No.Fish, na.rm=T)/(max(totArea, na.rm=T)), visit=max(visit))
#    #subresponse=summarize(subresponse, var=sum(No.Fish, na.rm=T)/(sum(Area, na.rm=T)), visit=max(visit))
# }
#  if(responsevar=="Density"& ROI=="hydro"){
#    subresponse=summarize(subresponse, var=sum(No.Fish, na.rm=T)/(sum(AreainDelft, na.rm=T)), visit=max(visit))
#    #print("Cannot generate estimates of density within hydro extent at this time, pick different ROI")
#  }
#  if(responsevar=="Density"& ROI=="hab"){
#    subresponse=summarize(subresponse, var=sum(No.Fish, na.rm=T)/(sum(SuitArea, na.rm=T)), visit=max(visit))
#  }
#  if(responsevar=="No.Fish"){
#    subresponse=summarize(subresponse, var=sum(No.Fish, na.rm=T), visit=max(visit))
#  }
#  if(responsevar=="Hab"& ROI=="bf"){
#    subresponse=summarize(subresponse, var=sum(SuitArea, na.rm=T)/(max(totArea, na.rm=T)), visit=max(visit))
#    #subresponse=summarize(subresponse, var=sum(SuitArea, na.rm=T)/(sum(Area, na.rm=T)), visit=max(visit))
#  }
#  if(responsevar=="Hab"& ROI=="hydro"){
#    subresponse=summarize(subresponse, var=sum(SuitArea, na.rm=T)/(sum(AreainDelft, na.rm=T)), visit=max(visit))
#    #print("Cannot generate estimates of hab within hydro extent at this time, pick different ROI")
#  }
#  if(responsevar=="MedModelVal"){
#    subresponse=summarize(subresponse, var=sum(AreainDelft*MedModelVal, na.rm=T)/sum(AreainDelft), visit=max(visit))
#  }
#  if(i==1){myresponse=subresponse}else{myresponse=rbind(myresponse,subresponse)}
#  
#}
# 
# 
# ##sets up column  headers to RS, RScond and Condition.
# selections0=selections
# RScol=which(colnames(selections0)==RScolname)
# 
# if(length(grep("Condition", names(selections)))==1){
#   selections0$RS=selections[,RScol]
#   Ccol=which(colnames(selections0)=="Condition")
#   selections0$RScond=paste(selections0[,RScol],selections0[,Ccol], sep="")
#   RScol=which(colnames(selections0)=="RScond")
# }else {
#   selections0$RS=selections[,RScol]
#   selections0$Condition=NA
#   Ccol=which(colnames(selections0)=="Condition")
#   selections0$RScond=paste(selections0[,RScol],selections0[,Ccol], sep="")}
# 
# 
# ##Pools data by none, RS or RScond
# 
# if(poolby=="none"){
#   myresponse2=myresponse%>%
#     filter(!is.na(Unit))%>%
#     group_by(Unit)%>%
#     summarize(avg=mean(var, na.rm=T), 
#               sd=sd(var, na.rm=T),
#               med=median(var, na.rm=T), 
#               min=min(var, na.rm=T) ,
#               max=max(var, na.rm=T),
#               n=length(na.omit(var)))%>%
#     mutate(RScond=NA, Condition=NA, RS=NA)
# }
# 
# if(poolby=="RScond"){
#   RSlist=levels(as.factor(selections0$RScond)) #create list of RS 
#   for(i in 1:length(RSlist)){
#     subdata1=filter(selections0, RScond==RSlist[i])%>%
#       select(RS, Condition,RScond,visit)%>%
#       left_join(myresponse, by="visit")%>%filter(!is.na(Unit))%>%
#       group_by(Unit, RS, Condition, RScond)%>%
#       summarize(avg=mean(var, na.rm=T), 
#                 sd=sd(var, na.rm=T),
#                 med=median(var, na.rm=T), 
#                 min=min(var, na.rm=T) ,
#                 max=max(var, na.rm=T),
#                 n=length(na.omit(var)))#%>%
#       #mutate(RScond=as.character(RSlist[i]))%>%
#       #extract(RScond, into = c("RS"), "(.[:upper:]*)", remove=F)%>%
#       #extract(RScond, into = c("Condition"), "([:lower:].*)", remove=F)
#     
#     if(i==1){myresponse2=subdata1}else{myresponse2=rbind(myresponse2,subdata1)}
#   }
# }
# 
# if(poolby=="RS"){
#   selections1=selections0
#     #extract(RScond, into = c("RS"), "(.[:upper:]*)", remove=F)
#   RSlist=levels(as.factor(selections1$RS)) #create list of RS 
#   for(i in 1:length(RSlist)){
#     subdata1=filter(selections1, RS==RSlist[i])%>%
#       select(RS,visit)%>%
#       distinct()%>%
#       left_join(myresponse, by="visit")%>%
#       filter(!is.na(Unit))%>%
#       group_by(Unit, RS, Condition=NA, RScond=NA)%>%
#       summarize(avg=mean(var, na.rm=T), 
#                 sd=sd(var, na.rm=T),
#                 med=median(var, na.rm=T), 
#                 min=min(var, na.rm=T) ,
#                 max=max(var, na.rm=T),
#                 n=length(na.omit(var)))
#     if(i==1){myresponse2=subdata1}else{myresponse2=rbind(myresponse2,subdata1)}
#   }
# }
# 




#OLD STUFF



#specify subdirectories in Outputs according to output variables 
#create.subdirs(PROJdir, c(basesubdir,"pred.fish"))
#create.subdirs(PROJdir, c(basesubdir, "pred.fish_perLength_m"))
#create.subdirs(PROJdir, c(basesubdir,  "pred.fish_perArea_m2"))
#create.subdirs(PROJdir, c(basesubdir, "area"))
#create.subdirs(PROJdir, c(basesubdir, "medModelVal"))
#create.subdirs(PROJdir, c(basesubdir,"meanModelVal"))
#create.subdirs(PROJdir, c(basesubdir, "sdModelVal"))

# 
# 
# #spreads table so that unit types are converted to columns and RS and Conditions are rows.   
# slim=myresponse2%>%
#   group_by(RS, Condition)%>%
#   select(-sd,-med,-min,-max,-n)%>%
#   spread(key="Unit", value=avg)
# 
# responses=list(response_stats=myresponse2, response_est=slim)
# 
# print(paste("layer = ", layer))
# print(paste("model = ", model))
# print(paste("ROI = ", ROI))
# print(paste("response = ", responsevar))
# print(paste("poolby = ", poolby))  
# print(responses)
# 
# write.csv(slim, paste(OUTfolder, "\\", "responseby", poolby, "_est.csv", sep=""), row.names=F)
# write.csv(myresponse2, paste(OUTfolder, "\\", "responseby", poolby, "_stats.csv", sep=""), row.names=F)
# print(paste("files successfully written to: ", OUTfolder,  sep=""))
# 
# 
# if(makeplot==T){
#   #responsechart=function(mydata=response_est,layer="Tier2_InChannel_Transition",model="NREI",
#   #                       responsevar="Density", ROI="bf", poolby="RS", OUTdir=F, plottype=".tiff"){
#   library(ggplot2)
#   mydata=slim
# 
#   #Read in and manipulate data for plotting
#   cols=length(names(mydata))  
#   
#   #re-formats data for easy plotting
#   print(paste("response=" , responsevar))
#   mydata1=gather(mydata, key="Unit", value=response, 4:(cols))
#   #names(mydata1)[which(names(mydata1)=='response')]=responsevar
#   
#   #sets up plotting theme
#   myplot <- ggplot(mydata1) +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1))
#   
#   
#   
#   if(poolby=="RScond"){
#     
#     #sets factor order to increase from poor to intact
#     mydata1$Condition=factor(mydata1$Condition, levels=c("poor", "mod", "good","intact"))
#     mycolors=c(poor="red", mod="yellow", good="green", intact="purple")
#     
#     
#     myplot <- ggplot(mydata1) +
#       theme(axis.text.x = element_text(angle = 90, hjust = 1))
#     
#     #plot1= myplot + geom_point(aes(x=Unit, y=response, col=Condition, shape=RS)) +
#     plot1= myplot + geom_point(aes(x=Unit, y=response, col=Condition, shape=RS)) +
#       scale_fill_manual(values = mycolors)
#     
#     plot2=myplot+geom_point(aes(x=RS, y=response, col=Condition)) +
#     #plot2=myplot+geom_point(aes(x=Condition, y=response, col=RS)) +
#       scale_fill_manual(values = mycolors)+
#       #scale_shape_manual("", values=c(17,17,16,16)
#       facet_grid( ~ Unit) +
#       facet_wrap( ~ Unit, scales='fixed')
#     
#     print(plot2)
#     if(is.na(OUTdir)==F){
#       
#       if(plottype==".pdf"){
#         ggsave(paste(OUTfolder, "\\","responseby", poolby,  "_facetbyUnit.pdf", sep=""), plot=plot2, width = 8, height = 6)}
#       
#       if(plottype==".png"){
#         ggsave(paste(OUTfolder, "\\","responseby",  poolby,  "_facetbyUnit.png", sep=""), plot=plot2, width = 8, height = 6)}
# 
#       if(plottype==".tiff"){
#         ggsave(paste(OUTfolder, "\\","responseby", poolby, "_facetbyUnit.tiff", sep=""), plot=plot2, width = 8, height = 6)}
#     }
#   }
#   
#   if(poolby=="RS"){
#     plot1= myplot + geom_point(aes(x=Unit, y=response, col=RS, shape=RS))
#   }
#   
#   if(poolby=="none"){    
#     plot1= myplot + geom_point(aes(x=Unit, y=response))
#   }
#   
#   
#   print(plot1)
#   
#   
#   
#   if(is.na(OUTdir)==F){
#     
#     if(plottype==".pdf"){
#       ggsave(paste(OUTfolder, "\\","responseby", poolby,  ".pdf", sep=""), plot=plot1, width = 8, height = 6)}
# 
#     if(plottype==".png"){
#       ggsave(paste(OUTfolder, "\\","responseby", poolby,  ".png", sep=""), plot=plot1, width = 8, height = 6)}
# 
#     if(plottype==".tiff"){
#       ggsave(paste(OUTfolder, "\\","responseby",  poolby,  ".tiff", sep=""), plot=plot1, width = 8, height = 6)}
#   }
#   
# }
# 
# 
# 
# #keepvars=c("criteria", "selections", "PROJdir","plottype", "DATAdir", "makeplot", "network", "layer", "model", "ROI", "responsevar", "poolby", "RScolname")
# #rm(list=ls()[-match(x = keepvars, table = ls())])
# 
# 
# if(validateselection==T){
#   keepvars=c("criteria", "selections", "PROJdir","plottype", "DATAdir", "makeplot", "layer", "model", "ROI", "responsevar", "poolby",
#              "upscalevar", "RScolname", "validateselection")
# }
# if(validateselection==F){
#   keepvars=c("criteria", "selections", "PROJdir","plottype", "DATAdir", "makeplot", "layer", "model", "ROI", "responsevar", "poolby", "network",
#              "upscalevar", "RScolname", "segIDcol" , "distcol", "bfwcol", "Areacols", "condcols","validateselection" )
# }
# 







